<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Generatore Ricette • OCR + Ingredienti</title>
  <meta name="theme-color" content="#10b981" />

  <style>
    :root { --brand:#10b981; --ink:#0f172a; --muted:#475569; --bg:#ffffff; }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif}
    header,main{max-width:1000px;margin:0 auto;padding:1rem}
    h1{font-size:clamp(1.4rem,2.5vw,2rem);margin:.25rem 0 1rem}
    p{color:var(--muted)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
    @media (max-width:860px){ .row{grid-template-columns:1fr} }
    .card{border:1px solid #e5e7eb;border-radius:14px;padding:1rem;background:#fff}
    .chips{display:flex;flex-wrap:wrap;gap:.5rem}
    .chip{background:#ecfdf5;color:#065f46;border:1px solid #a7f3d0;border-radius:999px;
      padding:.35rem .6rem;display:inline-flex;gap:.4rem;align-items:center;font-weight:600}
    .chip button{all:unset;cursor:pointer;font-weight:800}
    .controls{display:flex;gap:.5rem;flex-wrap:wrap}
    .btn{appearance:none;border:0;border-radius:.7rem;padding:.7rem 1rem;font-weight:700;
      cursor:pointer;background:var(--brand);color:#fff}
    .btn.secondary{background:#fff;color:var(--brand);border:2px solid var(--brand)}
    input[type="text"],input[type="file"],select{width:100%;padding:.7rem .8rem;border-radius:.6rem;
      border:1px solid #e5e7eb}
    .muted{color:var(--muted);font-size:.9rem}
    .ocrbox{min-height:120px;white-space:pre-wrap;background:#f8fafc;border-radius:.6rem;padding:.75rem;border:1px solid #e5e7eb}
    .thumb{max-width:100%;display:block;border-radius:.6rem;border:1px solid #e5e7eb}
    .spinner{display:inline-block;width:1em;height:1em;border:.18em solid #a7f3d0;border-top-color:#065f46;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .small{font-size:.85rem}
  </style>

  <!-- Tesseract.js per OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <!-- Plausible (opzionale) -->
  <script defer data-domain="salvatore251086.github.io/ricette-lista-spesa"
          data-api="https://plausible.io/api/event"
          src="https://plausible.io/js/script.js"></script>
  <script>
    window.plausible = window.plausible || function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}
  </script>
</head>
<body>
  <header>
    <h1>Generatore Ricette — Ingredienti & OCR</h1>
    <p class="muted">Aggiungi ingredienti a mano oppure fotografa la dispensa: estraiamo il testo con OCR e lo convertiamo in ingredienti reali dal tuo vocabolario.</p>
  </header>

  <main class="row">
    <!-- Colonna sinistra: input manuale + lista ingredienti -->
    <section class="card">
      <h2>1) Ingredienti</h2>
      <label class="muted small">Digita un ingrediente e premi Invio</label>
      <input id="ingInput" type="text" list="ingList" placeholder="Es. pomodori, cipolla, tonno…" autocomplete="off" />
      <datalist id="ingList"></datalist>

      <div class="chips" id="chips" style="margin-top:.75rem;"></div>

      <div class="controls" style="margin-top:1rem">
        <button class="btn" id="generateBtn">Genera ricette</button>
        <button class="btn secondary" id="clearBtn">Svuota</button>
      </div>

      <p class="muted small" style="margin-top:.5rem">Suggerimenti da file JSON: <code>assets/icons/json/ingredients-it.json</code></p>
    </section>

    <!-- Colonna destra: OCR -->
    <section class="card">
      <h2>2) Aggiungi con foto (OCR)</h2>
      <div class="controls">
        <input id="fileInput" type="file" accept="image/*" />
        <input id="cameraInput" type="file" accept="image/*" capture="environment" />
      </div>
      <p class="muted small">Carica una foto (scontrino, etichetta, dispensa) o scatta con la fotocamera.</p>

      <img id="preview" class="thumb" alt="" style="display:none;margin-top:.5rem" />

      <div style="margin-top:.75rem">
        <strong>Testo OCR</strong>
        <div id="ocrOut" class="ocrbox"></div>
      </div>

      <div class="muted small" style="margin-top:.5rem">
        Stato OCR: <span id="ocrStatus">inattivo</span>
      </div>
    </section>
  </main>

  <script>
    /**********************
     * 1) Carica vocabolario
     **********************/
    const VOCAB_PATH = 'assets/icons/json/ingredients-it.json';

    /** fallback super-essenziale */
    const FALLBACK_ING = [
      "acqua","aglio","basilico","burro","carote","ceci","cipolla","farina 00",
      "latte","limone","olio di oliva","origano","pane","pangrattato","parmigiano",
      "passata di pomodoro","patate","pepe","peperoncino","peperoni","piselli",
      "pomodori","polpa di pomodoro","pollo","ricotta","riso","sale","salvia",
      "spinaci","tonno","uova","zucchero","zucchine"
    ];

    let VOCAB = [];
    let vocSet; // Set normalizzato per match/ricerca

    async function loadVocab() {
      try {
        const res = await fetch(VOCAB_PATH, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        VOCAB = Array.isArray(data) ? data : FALLBACK_ING;
      } catch (e) {
        console.warn('Vocabolario: fallback locale (motivo:', e.message, ')');
        VOCAB = FALLBACK_ING;
      }
      // Populate datalist e set normalizzato
      const dl = document.getElementById('ingList');
      dl.innerHTML = '';
      VOCAB.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        dl.appendChild(opt);
      });
      vocSet = new Set(VOCAB.map(n => normalize(n)));
    }

    /**********************
     * 2) Gestione ingredienti manuali
     **********************/
    const chipsEl = document.getElementById('chips');
    const ingInput = document.getElementById('ingInput');
    const state = { ingredients: [] };

    function renderChips() {
      chipsEl.innerHTML = '';
      state.ingredients.forEach((name, idx) => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.innerHTML = `<span>${escapeHtml(name)}</span><button title="Rimuovi" aria-label="Rimuovi" data-idx="${idx}">×</button>`;
        chipsEl.appendChild(chip);
      });
    }

    chipsEl.addEventListener('click', (e) => {
      const idx = e.target?.dataset?.idx;
      if (idx !== undefined) {
        state.ingredients.splice(Number(idx), 1);
        renderChips();
      }
    });

    ingInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const raw = ingInput.value.trim();
        if (!raw) return;
        addIngredientSmart(raw);
        ingInput.value = '';
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      state.ingredients = [];
      renderChips();
    });

    document.getElementById('generateBtn').addEventListener('click', () => {
      if (state.ingredients.length === 0) {
        alert('Aggiungi almeno un ingrediente 🙂');
        return;
      }
      plausible('generate_recipes_click', { props: { count: state.ingredients.length } });
      // Per ora, redireziona alla home con querystring (o salta ad un tuo router)
      const q = encodeURIComponent(state.ingredients.join(','));
      location.href = `index.html?ingredients=${q}`;
    });

    /**********************
     * 3) OCR (Tesseract.js)
     **********************/
    const fileInput = document.getElementById('fileInput');
    const cameraInput = document.getElementById('cameraInput');
    const ocrOut = document.getElementById('ocrOut');
    const ocrStatus = document.getElementById('ocrStatus');
    const preview = document.getElementById('preview');

    fileInput.addEventListener('change', handleImage);
    cameraInput.addEventListener('change', handleImage);

    async function handleImage(e) {
      const file = e.target.files?.[0];
      if (!file) return;
      preview.src = URL.createObjectURL(file);
      preview.style.display = 'block';

      ocrStatus.innerHTML = 'avvio OCR… <span class="spinner" aria-hidden="true"></span>';
      ocrOut.textContent = '';

      try {
        const { data } = await Tesseract.recognize(file, 'ita+eng', {
          logger: (m) => {
            if (m.status && m.progress != null) {
              ocrStatus.textContent = `${m.status} ${Math.round(m.progress*100)}%`;
            }
          }
        });
        const text = (data?.text || '').trim();
        ocrOut.textContent = text || '(nessun testo riconosciuto)';
        plausible('ocr_done');

        const tokens = tokenize(text);
        const found = matchTokensToVocab(tokens);
        // aggiungi quelli nuovi
        found.forEach(addIngredientSmart);
      } catch (err) {
        console.error(err);
        ocrStatus.textContent = 'errore OCR';
        ocrOut.textContent = 'Si è verificato un errore durante l\'OCR.';
      } finally {
        if (ocrStatus.textContent.startsWith('errore') === false) {
          ocrStatus.textContent = 'completato';
        }
      }
    }

    /**********************
     * 4) Matching e utilità
     **********************/
    function addIngredientSmart(raw) {
      const norm = normalize(raw);
      // se già presente (in forma normalizzata) evita duplicati
      if (state.ingredients.some(x => normalize(x) === norm)) return;

      // Preferisci voce del vocabolario se esiste fuzzy match
      const best = bestMatchFromVocab(norm);
      state.ingredients.push(best || raw);
      renderChips();
    }

    function bestMatchFromVocab(normToken) {
      // match diretto
      if (vocSet?.has(normToken)) {
        // prendi la forma “bella” da VOCAB
        return VOCAB.find(v => normalize(v) === normToken) || normToken;
      }
      // fuzzy
      let best = null;
      let bestScore = 0;
      for (const v of VOCAB) {
        const score = similarity(normToken, normalize(v));
        if (score > bestScore) { bestScore = score; best = v; }
      }
      // soglia “umana”: >0.82
      return bestScore >= 0.82 ? best : null;
    }

    function matchTokensToVocab(tokens) {
      const out = [];
      tokens.forEach(t => {
        const m = bestMatchFromVocab(t);
        if (m) out.push(m);
      });
      // uniq mantenendo ordine
      return [...new Set(out)];
    }

    function tokenize(text) {
      return text
        .toLowerCase()
        .replace(/[^\p{L}\p{N}\s]/gu, ' ')
        .split(/\s+/)
        .filter(Boolean)
        .map(normalize)
        .filter(x => x.length >= 3);
    }

    function normalize(s) {
      return s
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // accenti
        .replace(/[^a-z0-9\s]/g,'')
        .replace(/\s+/g,' ')
        .trim();
    }

    function similarity(a, b) {
      // Jaro–Winkler leggero (semplificato) + bonus prefisso
      const m = jaro(a, b);
      const prefix = commonPrefixLen(a, b);
      return m + Math.min(0.1, 0.1 * prefix); // bonus fino a 0.1
    }

    function jaro(a, b) {
      if (a === b) return 1;
      const aLen = a.length, bLen = b.length;
      if (!aLen || !bLen) return 0;
      const matchDist = Math.floor(Math.max(aLen, bLen) / 2) - 1;
      const aMatches = new Array(aLen).fill(false);
      const bMatches = new Array(bLen).fill(false);
      let matches = 0;

      for (let i=0; i<aLen; i++) {
        const start = Math.max(0, i - matchDist);
        const end = Math.min(i + matchDist + 1, bLen);
        for (let j=start; j<end; j++) {
          if (bMatches[j]) continue;
          if (a[i] !== b[j]) continue;
          aMatches[i] = true; bMatches[j] = true; matches++; break;
        }
      }
      if (!matches) return 0;

      let t = 0, k = 0;
      for (let i=0; i<aLen; i++) {
        if (!aMatches[i]) continue;
        while (!bMatches[k]) k++;
        if (a[i] !== b[k]) t++;
        k++;
      }
      t /= 2;
      return (matches / aLen + matches / bLen + (matches - t) / matches) / 3;
    }

    function commonPrefixLen(a, b, max=4) {
      let n=0;
      for (; n<Math.min(max,a.length,b.length); n++) {
        if (a[n] !== b[n]) break;
      }
      return n;
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }

    // boot
    loadVocab();
  </script>
</body>
</html>
